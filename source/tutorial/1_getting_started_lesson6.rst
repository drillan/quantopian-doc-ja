
Data Processing in Algorithms
-----------------------------

次のステップでは、Researchで構築した data pipeline をアルゴリズムに統合します。 Research との重要な違いは、バックテストの間、シミュレーションの進行に合わせて pipeline が必ず毎日実行されることです。 したがって、 ``start_date`` と ``end_date`` を記述する必要はありません。

アルゴリズムの中で data pipeline を使うためには、まずアルゴリズムの ``initialize`` 関数の中に data pipeline への参照を追加します。これは ``attach_pipeline`` メソッドを使って行います。これには2つの入力が必要です。一つめは、``Pipeline`` オブジェクトへの参照（これは、 ``make_pipeline`` を使って作成します。）、　もう一つは、その参照名の ``文字列`` です。

.. code:: python

    # Algorithm API　をインポート
    import quantopian.algorithm as algo


    def initialize(context):
        # アルゴリズムを pipeline に 取り付ける
        algo.attach_pipeline(
            make_pipeline(),
            'data_pipe'
        )

        # rebalance 関数をスケジュールする
        algo.schedule_function(
            rebalance,
            date_rule=algo.date_rules.week_start(),
            time_rule=algo.time_rules.market_open()
        )


    def before_trading_start(context, data):
        pass


    def rebalance(context, data):
        pass


As mentioned above, our pipeline will process data streams and generate an output before the market opens each day. We can get our pipeline's output in ``before_trading_start`` using the ``pipeline_output`` function, which takes the pipeline name we specified in ``initialize``, and returns the pandas DataFrame generated by our pipeline. For now we can use our rebalance function to log the top 10 rows from our pipeline's output.

冒頭で述べたように、私たちの pipeline は、毎日実行されます。　毎日、マーケットが開く前に、データを処理して出力を生成します。　この出力は、　``pipeline_output`` 関数を使って ``before_trading_start`` で、得ることが出来ます。　得られた出力は、 pandas の DataFrame 型のデータです。では、 rebalance 関数で、毎日生成される pipeline の出力の最初の10行だけをログに出力してみましょう。


.. code:: python

    # Algorithm APIをインポート
    import quantopian.algorithm as algo


    def initialize(context):
        # algorithm に pipeline を取り付ける
        algo.attach_pipeline(
            make_pipeline(),
            'data_pipe'
        )

        # rebalance 関数をスケジュールする
        algo.schedule_function(
            rebalance,
            date_rule=algo.date_rules.week_start(),
            time_rule=algo.time_rules.market_open()
        )


    def before_trading_start(context, data):
        # pipeline の出力結果を取得。
        # それを、context.pipeline_data 変数へ格納する。
        context.pipeline_data = algo.pipeline_output(
            'data_pipe'
        )


    def rebalance(context, data):
        # pipeline の出力結果の最初の10行だけをログに出力
        log.info(context.pipeline_data.head(10))


では、Research で作った ``make_pipeline`` 関数をアルゴリズムに追加してみましょう。
このアルゴリズムでは、トレーディング・ユニバースに入っている資産の中で、センチメントスコアを持っている全ての資産を、数の制限をすることなしに、取引対象として考慮しなければなりません。
そのためには ``sentiment_score`` 出力が持つ、 ``notnull``` メソッドを使ってフィルタを作成してフィルタリングし、 ``&`` 演算子を使って、トレーディング・ユニバースから、取引すべきユニバース（取引対象銘柄群）を得ます。


.. code:: python

    # Algorithm API インポート
    import quantopian.algorithm as algo

    # Pipeline インポート
    from quantopian.pipeline import Pipeline
    from quantopian.pipeline.data.psychsignal import stocktwits
    from quantopian.pipeline.factors import SimpleMovingAverage
    from quantopian.pipeline.filters import QTradableStocksUS


    def initialize(context):
        # algorithm に pipeline を取り付ける
        algo.attach_pipeline(
            make_pipeline(),
            'data_pipe'
        )

        # rebalance 関数をスケジュールする
        algo.schedule_function(
            rebalance,
            date_rule=algo.date_rules.week_start(),
            time_rule=algo.time_rules.market_open()
        )


    def before_trading_start(context, data):
        # pipeline の出力結果を取得。
        # それを、context.pipeline_data 変数へ格納する。
        context.pipeline_data = algo.pipeline_output('data_pipe')


    def rebalance(context, data):
        # pipeline の出力結果の最初の10行だけをログに出力
        log.info(context.pipeline_data.head(10))


    # Pipeline definition
    def make_pipeline():

        base_universe = QTradableStocksUS()

        sentiment_score = SimpleMovingAverage(
            inputs=[stocktwits.bull_minus_bear],
            window_length=3,
        )

        return Pipeline(
            columns={
                'sentiment_score': sentiment_score,
            },
            screen=(
                base_universe
                & sentiment_score.notnull()
            )
        )


これで、私たちのアルゴリズムは、毎日、取引可能なユニバースを作り、ポートフォリオ内の資産配分を決定するために使うアルファスコアを生成します。次のレッスンでは、 data pipeline によって生成されたアルファスコアに基づいて最適なポートフォリオを構築する方法を学びます。
